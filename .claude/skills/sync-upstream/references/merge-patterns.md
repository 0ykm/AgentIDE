# マージ戦略と競合解決パターン集

## 1. ファイルタイプ別マージ戦略

### ソースコード（.ts, .tsx, .js, .jsx）

| パターン | 自動解決 | 対応方法 |
|----------|----------|----------|
| import文の追加（重複なし） | Yes | 両方を保持、アルファベット順にソート |
| import文の追加（重複あり） | Yes | 重複を除去して保持 |
| 異なる関数の追加 | Yes | 両方を保持 |
| 同一関数の異なる修正 | No | ユーザーにヒアリング |
| 型定義の拡張（互換性あり） | Yes | 両方のフィールドを保持 |
| 型定義の変更（互換性なし） | No | ユーザーにヒアリング |
| エクスポートの追加 | Yes | 両方を保持 |

### 設定ファイル（.json, .yaml, .toml）

| パターン | 自動解決 | 対応方法 |
|----------|----------|----------|
| 異なるキーの追加 | Yes | 両方のキーを保持 |
| 同一キーの異なる値 | No | ユーザーにヒアリング |
| バージョン番号の変更 | No | ユーザーにヒアリング |
| 依存関係の追加（重複なし） | Yes | 両方を保持 |
| 依存関係のバージョン変更 | No | ユーザーにヒアリング |

### package.json 特有の対応

| フィールド | 戦略 |
|-----------|-------|
| dependencies | 両方の追加を保持、バージョン競合はヒアリング |
| devDependencies | 同上 |
| scripts | 異なるスクリプト名は両方保持、同名はヒアリング |
| version | ユーザーにヒアリング |
| name, description | ユーザーにヒアリング |

### ロックファイル（package-lock.json, yarn.lock）

ロックファイルの競合は手動解決せず、マージ後に再生成する。

> **注意**: `git merge original/main` 実行時、`--theirs` は `original/main` 側（fork元）の内容を指し、`--ours` は現在のブランチ（origin/main起点）の内容を指す。以下ではfork元のロックファイルを基準にして再生成する戦略を採る。

```bash
# package-lock.jsonの場合
git checkout --theirs package-lock.json
npm install

# yarn.lockの場合
git checkout --theirs yarn.lock
yarn install
```

### ドキュメント（.md）

| パターン | 自動解決 | 対応方法 |
|----------|----------|----------|
| 異なるセクションの追加 | Yes | 両方を保持 |
| 同一セクションの変更 | No | ユーザーにヒアリング |
| TOC（目次）の更新 | Yes | マージ後に再生成 |

---

## 2. 競合分析の手順

### ステップ1: 競合マーカーの解析

```
<<<<<<< HEAD
（現在のブランチの変更 = origin/main）
=======
（マージ元の変更 = original/main）
>>>>>>> original/main
```

### ステップ2: 変更意図の推定

各変更について以下を分析する:

1. **変更の種類**: 追加 / 修正 / 削除 / リファクタリング
2. **影響範囲**: ローカル（関数内） / モジュール全体 / システム全体
3. **依存関係**: 他のファイルの変更に依存しているか
4. **互換性**: 両方の変更を同時に適用できるか

### ステップ3: 解決方針の決定

```
┌─────────────────────────────────┐
│ 変更が異なる箇所にある？         │
├────────┬────────────────────────┤
│ Yes    │ → 自動マージ            │
├────────┴────────────────────────┤
│ No                              │
├─────────────────────────────────┤
│ 変更の意図が同じ方向？           │
├────────┬────────────────────────┤
│ Yes    │ → より完全な方を採用     │
├────────┴────────────────────────┤
│ No                              │
├─────────────────────────────────┤
│ → ユーザーにヒアリング          │
└─────────────────────────────────┘
```

---

## 3. askmeスキルとの連携パターン

### 競合報告テンプレート

ユーザーにヒアリングする際は以下の情報を提供する:

```
## 競合: {ファイルパス}

### fork元（original/main）の変更
- 変更内容: {概要}
- 変更意図: {推定される意図}

### 現在のリポジトリ（origin/main）の変更
- 変更内容: {概要}
- 変更意図: {推定される意図}

### 推奨選択肢
1. fork元の変更を採用
2. 現在の変更を維持
3. 統合案: {具体的な統合方法}
4. スキップ（後で手動対応）
```

### 複数競合の効率的な処理

競合が多数ある場合:

1. 全競合ファイルを一覧表示
2. 関連するファイルをグループ化
3. グループ単位でユーザーに確認（個別ファイルごとではなく）
4. 共通パターンの競合は方針を一括確認

---

## 4. モノレポ固有の考慮事項

### ワークスペース構成での注意点

```
apps/
  web/        → フロントエンド変更
  server/     → バックエンド変更
  desktop/    → デスクトップアプリ変更
packages/
  shared/     → 共有パッケージ変更
```

- `packages/shared` の変更は `apps/*` に影響する可能性がある
- ビルド順序の依存関係を考慮する: shared → web → server → desktop
- 各ワークスペースの `package.json` は独立して管理される

### ビルド確認の推奨

マージ完了後、影響を受けるワークスペースのビルドを推奨する:

```bash
# shared が変更された場合
npm run build -w packages/shared

# web が変更された場合
npm run build -w apps/web

# 全体ビルド
npm run build
```

---

## 5. トラブルシューティング

### マージの取り消し

マージ中に問題が発生した場合:

```bash
# マージを中止（競合解決中の場合）
git merge --abort

# ブランチを削除して最初からやり直す
git checkout main
git branch -D future/{yyyyMMddHH}
```

### 未コミット変更の保護

作業開始前に未コミット変更がある場合:

```bash
# stashで退避
git stash push -m "sync-upstream作業前の退避"

# 作業完了後に復元
git stash pop
```

### リモート接続の問題

`original` リモートへの接続に失敗する場合:

```bash
# SSH接続を確認
ssh -T git@github.com

# HTTPS に切り替え
git remote set-url original https://github.com/{owner}/{repo}.git
```
